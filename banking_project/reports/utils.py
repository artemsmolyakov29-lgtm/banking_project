import csv
import json
import os
import tempfile
import zipfile
from datetime import datetime, timedelta
from decimal import Decimal
from django.db.models import Sum, Avg, Count, Q, F
from django.utils import timezone
from django.http import HttpResponse
from django.template.loader import render_to_string
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage
import logging

logger = logging.getLogger(__name__)


class ReportExporter:
    """Класс для экспорта данных в различные форматы"""

    @staticmethod
    def export_to_json(data, filename=None, include_metadata=False):
        """Экспорт данных в JSON"""
        if include_metadata:
            export_data = {
                'metadata': {
                    'export_date': timezone.now().isoformat(),
                    'record_count': len(data),
                    'version': '1.0'
                },
                'data': data
            }
        else:
            export_data = data

        response = HttpResponse(
            json.dumps(export_data, ensure_ascii=False, indent=2),
            content_type='application/json; charset=utf-8'
        )

        if not filename:
            filename = f"export_{timezone.now().strftime('%Y%m%d_%H%M%S')}.json"

        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        return response

    @staticmethod
    def export_to_csv(data, filename=None, include_metadata=False):
        """Экспорт данных в CSV"""
        if not data:
            return None

        response = HttpResponse(content_type='text/csv; charset=utf-8')

        if not filename:
            filename = f"export_{timezone.now().strftime('%Y%m%d_%H%M%S')}.csv"

        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        response.write('\ufeff')  # BOM для корректного отображения кириллицы в Excel

        writer = csv.writer(response)

        # Заголовки
        headers = list(data[0].keys())
        writer.writerow(headers)

        # Данные
        for item in data:
            row = []
            for key in headers:
                value = item.get(key, '')
                # Преобразуем Decimal в строку
                if isinstance(value, Decimal):
                    value = str(value)
                # Преобразуем даты в строки
                elif isinstance(value, (datetime, timezone.datetime)):
                    value = value.strftime('%Y-%m-%d %H:%M:%S')
                row.append(value)
            writer.writerow(row)

        if include_metadata:
            writer.writerow([])
            writer.writerow(['# Metadata'])
            writer.writerow(['# Export Date:', timezone.now().isoformat()])
            writer.writerow(['# Record Count:', len(data)])

        return response

    @staticmethod
    def export_to_xlsx(data, filename=None, include_metadata=False):
        """Экспорт данных в Excel (XLSX)"""
        try:
            # Попробуем использовать openpyxl если установлен
            from openpyxl import Workbook
            from openpyxl.styles import Font, Alignment

            wb = Workbook()
            ws = wb.active
            ws.title = "Data"

            if data:
                # Заголовки
                headers = list(data[0].keys())
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=1, column=col, value=header)
                    cell.font = Font(bold=True)
                    cell.alignment = Alignment(horizontal='center')

                # Данные
                for row_idx, item in enumerate(data, 2):
                    for col_idx, key in enumerate(headers, 1):
                        value = item.get(key, '')
                        if isinstance(value, Decimal):
                            value = float(value)
                        ws.cell(row=row_idx, column=col_idx, value=value)

            if include_metadata:
                # Добавляем лист с метаданными
                metadata_ws = wb.create_sheet("Metadata")
                metadata_ws['A1'] = 'Export Date'
                metadata_ws['B1'] = timezone.now().isoformat()
                metadata_ws['A2'] = 'Record Count'
                metadata_ws['B2'] = len(data)
                metadata_ws['A3'] = 'Generated By'
                metadata_ws['B3'] = 'Banking System'

            response = HttpResponse(
                content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            )

            if not filename:
                filename = f"export_{timezone.now().strftime('%Y%m%d_%H%M%S')}.xlsx"

            response['Content-Disposition'] = f'attachment; filename="{filename}"'
            wb.save(response)

            return response

        except ImportError:
            # Если openpyxl не установлен, используем CSV с расширением xlsx
            logger.warning("openpyxl not installed, using CSV fallback for Excel export")
            response = ReportExporter.export_to_csv(data, filename, include_metadata)
            if response and filename:
                response['Content-Disposition'] = f'attachment; filename="{filename}"'
                response['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            return response

    @staticmethod
    def export_to_pdf(html_content, filename=None):
        """Экспорт HTML контента в PDF"""
        try:
            from weasyprint import HTML
            from weasyprint.text.fonts import FontConfiguration

            font_config = FontConfiguration()
            html = HTML(string=html_content)

            response = HttpResponse(content_type='application/pdf')

            if not filename:
                filename = f"export_{timezone.now().strftime('%Y%m%d_%H%M%S')}.pdf"

            response['Content-Disposition'] = f'attachment; filename="{filename}"'

            html.write_pdf(response, font_config=font_config)
            return response

        except ImportError:
            # Если WeasyPrint не установлен, возвращаем HTML
            logger.warning("WeasyPrint not installed, using HTML fallback for PDF export")
            response = HttpResponse(html_content, content_type='text/html')
            if filename:
                response['Content-Disposition'] = f'attachment; filename="{filename.replace(".pdf", ".html")}"'
            return response

    @staticmethod
    def create_zip_archive(files_data, zip_filename=None):
        """Создание ZIP архива с несколькими файлами"""
        if not zip_filename:
            zip_filename = f"export_{timezone.now().strftime('%Y%m%d_%H%M%S')}.zip"

        temp_dir = tempfile.mkdtemp()
        zip_path = os.path.join(temp_dir, zip_filename)

        try:
            with zipfile.ZipFile(zip_path, 'w') as zip_file:
                for file_data in files_data:
                    filename = file_data['filename']
                    content = file_data['content']

                    if isinstance(content, str):
                        content = content.encode('utf-8')

                    zip_file.writestr(filename, content)

            # Читаем созданный ZIP файл
            with open(zip_path, 'rb') as f:
                zip_content = f.read()

            response = HttpResponse(zip_content, content_type='application/zip')
            response['Content-Disposition'] = f'attachment; filename="{zip_filename}"'

            return response

        finally:
            # Очищаем временные файлы
            import shutil
            shutil.rmtree(temp_dir)


class DataProcessor:
    """Класс для обработки и подготовки данных отчетов"""

    @staticmethod
    def prepare_client_data(clients_queryset):
        """Подготовка данных клиентов для экспорта"""
        data = []
        for client in clients_queryset:
            data.append({
                'id': client.id,
                'full_name': client.full_name,
                'inn': client.inn,
                'phone': getattr(client.user, 'phone', '') if hasattr(client, 'user') else '',
                'email': getattr(client.user, 'email', '') if hasattr(client, 'user') else '',
                'credit_rating': client.credit_rating,
                'is_vip': client.is_vip,
                'created_at': client.created_at.strftime('%Y-%m-%d') if client.created_at else '',
                'updated_at': client.updated_at.strftime('%Y-%m-%d %H:%M') if client.updated_at else '',
            })
        return data

    @staticmethod
    def prepare_credit_data(credits_queryset):
        """Подготовка данных кредитов для экспорта"""
        data = []
        for credit in credits_queryset:
            data.append({
                'id': credit.id,
                'client_name': credit.client.full_name if credit.client else '',
                'client_inn': credit.client.inn if credit.client else '',
                'amount': str(credit.amount),
                'interest_rate': str(credit.interest_rate),
                'term_months': credit.term_months,
                'remaining_amount': str(getattr(credit, 'remaining_amount', Decimal('0'))),
                'overdue_amount': str(getattr(credit, 'overdue_amount', Decimal('0'))),
                'status': credit.status,
                'status_display': credit.get_status_display(),
                'start_date': credit.start_date.strftime('%Y-%m-%d') if credit.start_date else '',
                'end_date': credit.end_date.strftime('%Y-%m-%d') if credit.end_date else '',
                'created_at': credit.created_at.strftime('%Y-%m-%d %H:%M') if credit.created_at else '',
            })
        return data

    @staticmethod
    def prepare_deposit_data(deposits_queryset):
        """Подготовка данных депозитов для экспорта"""
        data = []
        for deposit in deposits_queryset:
            data.append({
                'id': deposit.id,
                'client_name': deposit.client.full_name if deposit.client else '',
                'client_inn': deposit.client.inn if deposit.client else '',
                'amount': str(deposit.amount),
                'interest_rate': str(deposit.interest_rate),
                'deposit_type': deposit.deposit_type,
                'deposit_type_display': deposit.get_deposit_type_display(),
                'capitalization': deposit.capitalization,
                'capitalization_display': deposit.get_capitalization_display(),
                'status': deposit.status,
                'status_display': deposit.get_status_display(),
                'start_date': deposit.start_date.strftime('%Y-%m-%d') if deposit.start_date else '',
                'end_date': deposit.end_date.strftime('%Y-%m-%d') if deposit.end_date else '',
                'total_accrued_interest': str(getattr(deposit, 'get_total_accrued_interest', lambda: Decimal('0'))()),
                'created_at': deposit.created_at.strftime('%Y-%m-%d %H:%M') if deposit.created_at else '',
            })
        return data

    @staticmethod
    def prepare_transaction_data(transactions_queryset):
        """Подготовка данных транзакций для экспорта"""
        data = []
        for transaction in transactions_queryset:
            data.append({
                'id': transaction.id,
                'amount': str(transaction.amount),
                'transaction_type': transaction.transaction_type,
                'transaction_type_display': transaction.get_transaction_type_display(),
                'description': transaction.description,
                'fee': str(transaction.fee),
                'status': transaction.status,
                'status_display': transaction.get_status_display(),
                'created_at': transaction.created_at.strftime('%Y-%m-%d %H:%M:%S') if transaction.created_at else '',
            })
        return data

    @staticmethod
    def prepare_card_data(cards_queryset):
        """Подготовка данных карт для экспорта"""
        data = []
        for card in cards_queryset:
            data.append({
                'id': card.id,
                'card_number': getattr(card, 'get_masked_number', lambda: '**** **** **** ****')(),
                'cardholder_name': card.cardholder_name,
                'account_number': card.account.account_number if card.account else '',
                'client_name': card.account.client.full_name if card.account and card.account.client else '',
                'card_type': card.card_type,
                'card_type_display': card.get_card_type_display(),
                'card_system': card.card_system,
                'card_system_display': card.get_card_system_display(),
                'status': card.status,
                'status_display': card.get_status_display(),
                'daily_limit': str(card.daily_limit),
                'expiry_date': card.expiry_date.strftime('%Y-%m-%d') if card.expiry_date else '',
                'is_virtual': card.is_virtual,
                'created_at': card.created_at.strftime('%Y-%m-%d %H:%M') if card.created_at else '',
            })
        return data


class ReportScheduler:
    """Класс для управления расписанием отчетов"""

    @staticmethod
    def check_pending_schedules():
        """Проверка расписаний, которые нужно выполнить"""
        from .models import ReportSchedule
        from django.utils import timezone

        now = timezone.now()
        schedules_to_run = []

        schedules = ReportSchedule.objects.filter(is_active=True)

        for schedule in schedules:
            if schedule.should_generate_now():
                schedules_to_run.append(schedule)

        return schedules_to_run

    @staticmethod
    def execute_schedule(schedule):
        """Выполнение запланированного отчета"""
        try:
            # Здесь будет логика генерации отчета по расписанию
            # Пока заглушка
            logger.info(f"Executing schedule: {schedule.name}")

            # Обновляем время последней генерации
            schedule.mark_generated()

            return True
        except Exception as e:
            logger.error(f"Error executing schedule {schedule.name}: {str(e)}")
            return False

    @staticmethod
    def cleanup_old_reports(days_old=30):
        """Очистка старых временных отчетов"""
        from .models import SavedReport
        from django.utils import timezone

        cutoff_date = timezone.now() - timedelta(days=days_old)
        old_reports = SavedReport.objects.filter(
            is_temporary=True,
            generated_at__lt=cutoff_date
        )

        deleted_count = 0
        for report in old_reports:
            if report.cleanup_file():
                report.delete()
                deleted_count += 1

        return deleted_count


class AnalyticsCalculator:
    """Класс для аналитических расчетов"""

    @staticmethod
    def calculate_financial_metrics(date_from=None, date_to=None):
        """Расчет финансовых метрик"""
        from django.apps import apps

        # Ленивая загрузка моделей
        Account = apps.get_model('accounts', 'Account')
        Credit = apps.get_model('credits', 'Credit')
        Deposit = apps.get_model('deposits', 'Deposit')
        Transaction = apps.get_model('transactions', 'Transaction')

        if not date_from:
            date_from = timezone.now() - timedelta(days=30)
        if not date_to:
            date_to = timezone.now()

        metrics = {
            'period': {
                'from': date_from,
                'to': date_to
            },
            'assets': {
                'total_balance': Account.objects.filter(status='active').aggregate(
                    total=Sum('balance')
                )['total'] or Decimal('0'),
                'accounts_count': Account.objects.filter(status='active').count(),
            },
            'credits': {
                'total_amount': Credit.objects.filter(status='active').aggregate(
                    total=Sum('amount')
                )['total'] or Decimal('0'),
                'active_count': Credit.objects.filter(status='active').count(),
                'overdue_amount': Credit.objects.filter(status='active').aggregate(
                    total=Sum('overdue_amount')
                )['total'] or Decimal('0'),
            },
            'deposits': {
                'total_amount': Deposit.objects.filter(status='active').aggregate(
                    total=Sum('amount')
                )['total'] or Decimal('0'),
                'active_count': Deposit.objects.filter(status='active').count(),
            },
            'transactions': {
                'total_volume': Transaction.objects.filter(
                    created_at__range=[date_from, date_to]
                ).aggregate(total=Sum('amount'))['total'] or Decimal('0'),
                'total_count': Transaction.objects.filter(
                    created_at__range=[date_from, date_to]
                ).count(),
                'total_fee': Transaction.objects.filter(
                    created_at__range=[date_from, date_to]
                ).aggregate(total=Sum('fee'))['total'] or Decimal('0'),
            }
        }

        return metrics

    @staticmethod
    def calculate_growth_metrics(period_days=30):
        """Расчет метрик роста"""
        from django.apps import apps

        Client = apps.get_model('clients', 'Client')
        Account = apps.get_model('accounts', 'Account')

        end_date = timezone.now()
        start_date = end_date - timedelta(days=period_days)

        # Новые клиенты за период
        new_clients = Client.objects.filter(
            created_at__range=[start_date, end_date]
        ).count()

        # Новые счета за период
        new_accounts = Account.objects.filter(
            created_at__range=[start_date, end_date]
        ).count()

        # Общее количество на начало периода
        total_clients_start = Client.objects.filter(
            created_at__lt=start_date
        ).count()

        total_accounts_start = Account.objects.filter(
            created_at__lt=start_date
        ).count()

        # Расчет роста
        client_growth = (new_clients / total_clients_start * 100) if total_clients_start > 0 else 0
        account_growth = (new_accounts / total_accounts_start * 100) if total_accounts_start > 0 else 0

        return {
            'period_days': period_days,
            'new_clients': new_clients,
            'new_accounts': new_accounts,
            'client_growth_percent': round(client_growth, 2),
            'account_growth_percent': round(account_growth, 2),
        }


class TemplateRenderer:
    """Класс для рендеринга шаблонов отчетов"""

    @staticmethod
    def render_report_template(template, context):
        """Рендеринг шаблона отчета"""
        try:
            from django.template import Template, Context
            from django.template.loader import get_template

            if hasattr(template, 'template_content'):
                # Если шаблон хранится в базе данных
                django_template = Template(template.template_content)
                rendered_content = django_template.render(Context(context))
            else:
                # Если используется файловый шаблон
                template_path = getattr(template, 'template_path', 'reports/default_template.html')
                django_template = get_template(template_path)
                rendered_content = django_template.render(context)

            return rendered_content

        except Exception as e:
            logger.error(f"Error rendering template: {str(e)}")
            return f"<h1>Error rendering template: {str(e)}</h1>"

    @staticmethod
    def generate_preview_data(report_type, parameters):
        """Генерация данных для предпросмотра отчета"""
        # Здесь может быть логика генерации ограниченного набора данных для предпросмотра
        preview_data = {
            'report_type': report_type,
            'parameters': parameters,
            'sample_data': [],
            'generated_at': timezone.now().isoformat()
        }

        return preview_data


def get_available_export_formats():
    """Получение списка доступных форматов экспорта"""
    return [
        {'value': 'json', 'label': 'JSON', 'mime_type': 'application/json'},
        {'value': 'csv', 'label': 'CSV', 'mime_type': 'text/csv'},
        {'value': 'xlsx', 'label': 'Excel',
         'mime_type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'},
        {'value': 'pdf', 'label': 'PDF', 'mime_type': 'application/pdf'},
        {'value': 'html', 'label': 'HTML', 'mime_type': 'text/html'},
    ]


def validate_export_parameters(data_type, format, parameters):
    """Валидация параметров экспорта"""
    errors = []

    # Проверка типа данных
    valid_data_types = ['clients', 'credits', 'deposits', 'transactions', 'cards', 'financial']
    if data_type not in valid_data_types:
        errors.append(f"Неподдерживаемый тип данных: {data_type}")

    # Проверка формата
    valid_formats = ['json', 'csv', 'xlsx', 'pdf', 'html']
    if format not in valid_formats:
        errors.append(f"Неподдерживаемый формат: {format}")

    # Проверка дат если они указаны
    date_from = parameters.get('date_from')
    date_to = parameters.get('date_to')

    if date_from and date_to:
        try:
            from django.utils.dateparse import parse_date
            date_from_obj = parse_date(date_from)
            date_to_obj = parse_date(date_to)

            if date_from_obj and date_to_obj and date_from_obj > date_to_obj:
                errors.append("Дата 'с' не может быть позже даты 'по'")
        except (ValueError, TypeError):
            errors.append("Неверный формат даты")

    return errors